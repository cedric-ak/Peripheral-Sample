/*
 * File:   SSD1308_OLED.c
 * Author: CEDRIC
 *
 * Created on 05 April 2020, 4:37 PM
 */

#include "mcc_generated_files/mcc.h"

void SSD1306_Init(void) {
    
  SSD1306_RESET_SetHigh();
    __delay_ms(1);
    SSD1306_RESET_SetLow();
    __delay_ms(10);
    SSD1306_RESET_SetHigh();
    
SSD1306_writeCMD(SSD1306_DISPLAYOFF, SSD1306_DISPLAYOFF);             //0xAE Display OFF
#ifdef SSD1306_128_64
    SSD1306_writeCMD(SSD1306_SETMULTIPLEX,63);                     //0xA8 Set MUX Ratio to 64
#endif
#ifdef SSD1306_128_32
    SSD1306_writeCMD(SSD1306_SETMULTIPLEX, 0x1F); //0xA8 Set MUX Ratio to 32
#endif

    SSD1306_writeCMD(SSD1306_SETDISPLAYOFFSET, 0x00);                  //0xD3 Set Display Offset start at 0
    SSD1306_writeCMD(SSD1306_MEMORYMODE, 0x00);                        //0x20 memory addressing horizontal mode
    SSD1306_writeCMD(SSD1306_SETDISPLAYSTARTLINE, SSD1306_SETDISPLAYSTARTLINE); //0x40 Set Display Start Line to 0
    SSD1306_writeCMD(SSD1306_SEGREMAP_ADD_0, SSD1306_SEGREMAP_ADD_0);      //0xA0 Set Segment re-map A0h
    SSD1306_writeCMD(SSD1306_COMSCANINC, SSD1306_COMSCANINC);          //0xC0 Set COM Output Scan Direction Normal (0xC4 for mirror images)
  
#ifdef SSD1306_128_64
    SSD1306_writeCMD(SSD1306_SETCOMPINS, 0x12);                        //0xDA Sequential COM pin configuration, Disable COM Left/Right remap*(0X2)
    SSD1306_writeCMD(SSD1306_SETCONTRAST, 0x7F);                       //0x81 set display contrast 7F,8F
#endif
#ifdef SSD1306_128_32
    SSD1306_writeCMD(SSD1306_SETCOMPINS, 0x02);                        //0xDA Sequential COM pin configuration, Disable COM Left/Right remap
    SSD1306_writeCMD(SSD1306_SETCONTRAST, 0x8F); //set display contrast 
#endif
    
#ifdef SSD1306_96_16
    SSD1306_writeCMD(SSD1306_SETCOMPINS, 0x02); //0x12                       //0xDA Sequential COM pin configuration, Disable COM Left/Right remap
    SSD1306_writeCMD(SSD1306_SETCONTRAST, 0xAF); //set display contrast(0x10 for external vcc 
#endif
    SSD1306_writeCMD(SSD1306_SETPRECHARGE,SSD1306_SETPRECHARGE);         //set precharge period
    SSD1306_writeCMD(SSD1306_SETVCOMDETECT, 0x40);                     //0xDB
    SSD1306_writeCMD(SSD1306_DISPLAYALLON_RESUME, SSD1306_DISPLAYALLON_RESUME); //0xA4 Normal display mode
    SSD1306_writeCMD(SSD1306_NORMALDISPLAY, SSD1306_NORMALDISPLAY);       //0xA6 Normal display OFF in display panel *
    SSD1306_writeCMD(SSD1306_SETDISPLAYCLOCKDIV, 0x80);                //0xD5 Set osc Frequency
    SSD1306_writeCMD(SSD1306_CHARGEPUMP, 0x14);                        //0x8D Enable charge pump regulator
    SSD1306_writeCMD(SSD1306_DEACTIVATE_SCROLL,SSD1306_DEACTIVATE_SCROLL);    //0x2E deactivate scroll
    SSD1306_writeCMD(SSD1306_DISPLAYON, SSD1306_DISPLAYON);           //0xAF Display ON
      
}

/**********************************************************
 **Name:     SSD1306 write command
 **Function: Is used or called when writing commands to the display
 **Input:    control byte register
 **Output:   none
 **Note:     none
 **********************************************************/
void SSD1306_writeCMD(uint8_t controlReg, uint8_t dataByte) {
    I2C_start();
    I2C_Write(SSD1306_ADDRESS);
    I2C_Write(controlReg);
    dataByte == SSD1306_REG_NODATA ?  I2C_stop() :I2C_Write(dataByte);      
    I2C_stop();
}

void SSD1306_writeData(uint8_t data){
  uint8_t Control = 0x00;
  I2C_start();
  I2C_Write(SSD1306_ADDRESS);
  I2C_Write(Control);
  I2C_Write(data);
  I2C_stop();
}
#define ssd1306_swap(a, b) { int16_t t = a; a = b; b = t; }
// the memory buffer for the LCD
static uint8_t Buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
#if (SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH > 96*16)
0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#if (SSD1306_LCDHEIGHT == 64)
0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,
0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,
0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00,
0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E,
0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC,
0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06,
0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8,
0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00,
0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C,
0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F,
0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00,
0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07,
0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#endif
#endif
};



void drawPixel(int16_t x, int16_t y, uint16_t color){
    if ((x < 0) || (x >= width()) || (y < 0) || (y >= height()))
    return;  
    
     // check rotation, move pixel around if necessary
  switch (getRotation()) {
  case 1:
    ssd1306_swap(x, y);
    x = SSD1306_LCDWIDTH - x - 1;
    break;
  case 2:
    x = SSD1306_LCDWIDTH - x - 1;
    y = SSD1306_LCDHEIGHT - y - 1;
    break;
  case 3:
    ssd1306_swap(x, y);
    y = SSD1306_LCDHEIGHT - y - 1;
    break;
  }
    
      // x is which column
    switch (color)
    {
      case WHITE:   Buffer[x+ (y/8)*SSD1306_LCDWIDTH] |=  (1 << (y&7)); break;
      case BLACK:   Buffer[x+ (y/8)*SSD1306_LCDWIDTH] &= ~(1 << (y&7)); break;
      case INVERSE: Buffer[x+ (y/8)*SSD1306_LCDWIDTH] ^=  (1 << (y&7)); break;
    }
}



uint8_t getRotation(void){
    return rotation;
}

uint16_t width(void){
    return SSD1306_LCDWIDTH;
}

uint16_t height(void){
    return SSD1306_LCDHEIGHT;
}

void invertDisplay(uint8_t i){
    if(i){
        SSD1306_writeCMD(SSD1306_INVERTDISPLAY,SSD1306_INVERTDISPLAY);
        return;
    }  
    SSD1306_writeCMD(SSD1306_NORMALDISPLAY, SSD1306_NORMALDISPLAY);
}

// startscrollright
// Activate a right handed scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void startscrollright(uint8_t start, uint8_t stop){
    SSD1306_writeCMD(SSD1306_RIGHT_HORIZONTAL_SCROLL,SSD1306_RIGHT_HORIZONTAL_SCROLL);
    SSD1306_writeData(0X00);
    SSD1306_writeData(start);
    SSD1306_writeData(0X00);
    SSD1306_writeData(stop);
    SSD1306_writeData(0X00);
    SSD1306_writeData(0XFF);
    SSD1306_writeCMD(SSD1306_ACTIVATE_SCROLL,SSD1306_ACTIVATE_SCROLL);
}

// startscrollleft
// Activate a right handed scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void startscrollleft(uint8_t start, uint8_t stop){
    SSD1306_writeCMD(SSD1306_LEFT_HORIZONTAL_SCROLL,SSD1306_LEFT_HORIZONTAL_SCROLL);
    SSD1306_writeData(0X00);
    SSD1306_writeData(start);
    SSD1306_writeData(0X00);
    SSD1306_writeData(stop);
    SSD1306_writeData(0X00);
    SSD1306_writeData(0XFF);
    SSD1306_writeCMD(SSD1306_ACTIVATE_SCROLL,SSD1306_ACTIVATE_SCROLL);
}

// startscrolldiagright
// Activate a diagonal scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void startscrolldiagright(uint8_t start, uint8_t stop){
    SSD1306_writeCMD(SSD1306_SET_VERTICAL_SCROLL_AREA,0x00);
    SSD1306_writeCMD(SSD1306_LCDHEIGHT,SSD1306_LCDHEIGHT);
    SSD1306_writeCMD(SSD1306_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL,0x00);
    SSD1306_writeData(start);
    SSD1306_writeData(0X00);
    SSD1306_writeData(stop);
    SSD1306_writeData(0X01);
    SSD1306_writeCMD(SSD1306_ACTIVATE_SCROLL,SSD1306_ACTIVATE_SCROLL); 
}

void stopscroll(void){
    SSD1306_writeCMD(SSD1306_DEACTIVATE_SCROLL, SSD1306_DEACTIVATE_SCROLL);
}

void dim(bool status){
    uint8_t contrast;
    if(status){
     contrast = 0;  // display  
    }else{
//       contrast = 0x9F;  //for external VCC
       contrast = 0xCF;
    }
 // the range of contrast to too small to be really useful
  // it is useful to dim the display
    SSD1306_writeData(SSD1306_SETCONTRAST);
    SSD1306_writeData(contrast);
}

void display(void){
    SSD1306_writeData(SSD1306_COLUMNADDR);  
    SSD1306_writeData(0);// Column start address (0 = reset)
    SSD1306_writeData(SSD1306_LCDWIDTH-1); // Column end address (127 = reset)
    SSD1306_writeData(SSD1306_PAGEADDR);
    SSD1306_writeData(0); // Page start address (0 = reset
#ifdef SSD1306_128_64
    SSD1306_writeData(7);  //// Page end address
#endif
    #ifdef SSD1306_128_32
    SSD1306_writeData(3);
#endif 
#ifdef SSD1306_96_16   
    SSD1306_writeData(1);
#endif
    for(uint16_t i=0; i<(SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8); i++){
      // send a bunch of data in one xmission
        I2C_Write(SSD1306_ADDRESS);
        I2C_Write(0x40);
              for (uint8_t x=0; x<16; x++) {
        I2C_Write(Buffer[i]);
        i++;
      }
      i--;
      I2C_stop();
    }
//    SSD1306_writeData(  
}

void clearDisplay(void){
  memset(Buffer, 0, (SSD1306_LCDWIDTH*SSD1306_LCDHEIGHT/8));  
}

void setCursor(int16_t x, int16_t y){
    cursor_x = x;
    cursor_y = y; 
}

void setTextSize(uint8_t s){
    int textsize = (s > 0) ? s : 1;  //look at the correct way of doing it
}

void setTextColor(uint16_t c) {
       // For 'transparent' background, we'll set the bg
    // to the same as fg instead of using a flag
//    textcolor = textbgcolor = c; 
}

void setRotatation(uint8_t x){
       rotation = (x & 3);
    switch(rotation) {
        case 0:
        case 2:
//            _width  = WIDTH;
//            _height = HEIGHT;
            break;
        case 1:
        case 3:
//            _width  = HEIGHT;
//            _height = WIDTH;
            break;
    } 
}

/*Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
WIDTH(w), HEIGHT(h)
{
    _width    = WIDTH;
    _height   = HEIGHT;
    rotation  = 0;
    cursor_y  = cursor_x    = 0;
    textsize  = 1;
    textcolor = textbgcolor = 0xFFFF;
    wrap      = true;
    _cp437    = false;
    gfxFont   = NULL;
}*/